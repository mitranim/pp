{
  "version": 3,
  "sources": ["../../node_modules/@ungap/custom-elements/index.js", "../../node_modules/fpx/fpx.mjs", "../../node_modules/prax/dom.mjs", "../../scripts/browser.mjs"],
  "sourcesContent": ["/*! (c) Andrea Giammarchi @webreflection ISC */\n(function () {\n  'use strict';\n\n  var Lie = typeof Promise === 'function' ? Promise : function (fn) {\n    var queue = [],\n        resolved = 0,\n        value;\n    fn(function ($) {\n      value = $;\n      resolved = 1;\n      queue.splice(0).forEach(then);\n    });\n    return {\n      then: then\n    };\n\n    function then(fn) {\n      return resolved ? setTimeout(fn, 0, value) : queue.push(fn), this;\n    }\n  };\n\n  var attributesObserver = (function (whenDefined, MutationObserver) {\n    var attributeChanged = function attributeChanged(records) {\n      for (var i = 0, length = records.length; i < length; i++) {\n        dispatch(records[i]);\n      }\n    };\n\n    var dispatch = function dispatch(_ref) {\n      var target = _ref.target,\n          attributeName = _ref.attributeName,\n          oldValue = _ref.oldValue;\n      target.attributeChangedCallback(attributeName, oldValue, target.getAttribute(attributeName));\n    };\n\n    return function (target, is) {\n      var attributeFilter = target.constructor.observedAttributes;\n\n      if (attributeFilter) {\n        whenDefined(is).then(function () {\n          new MutationObserver(attributeChanged).observe(target, {\n            attributes: true,\n            attributeOldValue: true,\n            attributeFilter: attributeFilter\n          });\n\n          for (var i = 0, length = attributeFilter.length; i < length; i++) {\n            if (target.hasAttribute(attributeFilter[i])) dispatch({\n              target: target,\n              attributeName: attributeFilter[i],\n              oldValue: null\n            });\n          }\n        });\n      }\n\n      return target;\n    };\n  });\n\n  var TRUE = true,\n      FALSE = false;\n  var QSA$1 = 'querySelectorAll';\n\n  function add(node) {\n    this.observe(node, {\n      subtree: TRUE,\n      childList: TRUE\n    });\n  }\n  /**\n   * Start observing a generic document or root element.\n   * @param {Function} callback triggered per each dis/connected node\n   * @param {Element?} root by default, the global document to observe\n   * @param {Function?} MO by default, the global MutationObserver\n   * @returns {MutationObserver}\n   */\n\n\n  var notify = function notify(callback, root, MO) {\n    var loop = function loop(nodes, added, removed, connected, pass) {\n      for (var i = 0, length = nodes.length; i < length; i++) {\n        var node = nodes[i];\n\n        if (pass || QSA$1 in node) {\n          if (connected) {\n            if (!added.has(node)) {\n              added.add(node);\n              removed[\"delete\"](node);\n              callback(node, connected);\n            }\n          } else if (!removed.has(node)) {\n            removed.add(node);\n            added[\"delete\"](node);\n            callback(node, connected);\n          }\n\n          if (!pass) loop(node[QSA$1]('*'), added, removed, connected, TRUE);\n        }\n      }\n    };\n\n    var observer = new (MO || MutationObserver)(function (records) {\n      for (var added = new Set(), removed = new Set(), i = 0, length = records.length; i < length; i++) {\n        var _records$i = records[i],\n            addedNodes = _records$i.addedNodes,\n            removedNodes = _records$i.removedNodes;\n        loop(removedNodes, added, removed, FALSE, FALSE);\n        loop(addedNodes, added, removed, TRUE, FALSE);\n      }\n    });\n    observer.add = add;\n    observer.add(root || document);\n    return observer;\n  };\n\n  var QSA = 'querySelectorAll';\n  var _self$1 = self,\n      document$2 = _self$1.document,\n      Element$1 = _self$1.Element,\n      MutationObserver$2 = _self$1.MutationObserver,\n      Set$2 = _self$1.Set,\n      WeakMap$1 = _self$1.WeakMap;\n\n  var elements = function elements(element) {\n    return QSA in element;\n  };\n\n  var filter = [].filter;\n  var qsaObserver = (function (options) {\n    var live = new WeakMap$1();\n\n    var drop = function drop(elements) {\n      for (var i = 0, length = elements.length; i < length; i++) {\n        live[\"delete\"](elements[i]);\n      }\n    };\n\n    var flush = function flush() {\n      var records = observer.takeRecords();\n\n      for (var i = 0, length = records.length; i < length; i++) {\n        parse(filter.call(records[i].removedNodes, elements), false);\n        parse(filter.call(records[i].addedNodes, elements), true);\n      }\n    };\n\n    var matches = function matches(element) {\n      return element.matches || element.webkitMatchesSelector || element.msMatchesSelector;\n    };\n\n    var notifier = function notifier(element, connected) {\n      var selectors;\n\n      if (connected) {\n        for (var q, m = matches(element), i = 0, length = query.length; i < length; i++) {\n          if (m.call(element, q = query[i])) {\n            if (!live.has(element)) live.set(element, new Set$2());\n            selectors = live.get(element);\n\n            if (!selectors.has(q)) {\n              selectors.add(q);\n              options.handle(element, connected, q);\n            }\n          }\n        }\n      } else if (live.has(element)) {\n        selectors = live.get(element);\n        live[\"delete\"](element);\n        selectors.forEach(function (q) {\n          options.handle(element, connected, q);\n        });\n      }\n    };\n\n    var parse = function parse(elements) {\n      var connected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      for (var i = 0, length = elements.length; i < length; i++) {\n        notifier(elements[i], connected);\n      }\n    };\n\n    var query = options.query;\n    var root = options.root || document$2;\n    var observer = notify(notifier, root, MutationObserver$2);\n    var attachShadow = Element$1.prototype.attachShadow;\n    if (attachShadow) Element$1.prototype.attachShadow = function (init) {\n      var shadowRoot = attachShadow.call(this, init);\n      observer.add(shadowRoot);\n      return shadowRoot;\n    };\n    if (query.length) parse(root[QSA](query));\n    return {\n      drop: drop,\n      flush: flush,\n      observer: observer,\n      parse: parse\n    };\n  });\n\n  var _self = self,\n      document$1 = _self.document,\n      Map = _self.Map,\n      MutationObserver$1 = _self.MutationObserver,\n      Object$1 = _self.Object,\n      Set$1 = _self.Set,\n      WeakMap = _self.WeakMap,\n      Element = _self.Element,\n      HTMLElement = _self.HTMLElement,\n      Node = _self.Node,\n      Error = _self.Error,\n      TypeError = _self.TypeError,\n      Reflect = _self.Reflect;\n  var Promise$1 = self.Promise || Lie;\n  var defineProperty = Object$1.defineProperty,\n      keys = Object$1.keys,\n      getOwnPropertyNames = Object$1.getOwnPropertyNames,\n      setPrototypeOf = Object$1.setPrototypeOf;\n  var legacy = !self.customElements;\n\n  var expando = function expando(element) {\n    var key = keys(element);\n    var value = [];\n    var length = key.length;\n\n    for (var i = 0; i < length; i++) {\n      value[i] = element[key[i]];\n      delete element[key[i]];\n    }\n\n    return function () {\n      for (var _i = 0; _i < length; _i++) {\n        element[key[_i]] = value[_i];\n      }\n    };\n  };\n\n  if (legacy) {\n    var HTMLBuiltIn = function HTMLBuiltIn() {\n      var constructor = this.constructor;\n      if (!classes.has(constructor)) throw new TypeError('Illegal constructor');\n      var is = classes.get(constructor);\n      if (override) return augment(override, is);\n      var element = createElement.call(document$1, is);\n      return augment(setPrototypeOf(element, constructor.prototype), is);\n    };\n\n    var createElement = document$1.createElement;\n    var classes = new Map();\n    var defined = new Map();\n    var prototypes = new Map();\n    var registry = new Map();\n    var query = [];\n\n    var handle = function handle(element, connected, selector) {\n      var proto = prototypes.get(selector);\n\n      if (connected && !proto.isPrototypeOf(element)) {\n        var redefine = expando(element);\n        override = setPrototypeOf(element, proto);\n\n        try {\n          new proto.constructor();\n        } finally {\n          override = null;\n          redefine();\n        }\n      }\n\n      var method = \"\".concat(connected ? '' : 'dis', \"connectedCallback\");\n      if (method in proto) element[method]();\n    };\n\n    var _qsaObserver = qsaObserver({\n      query: query,\n      handle: handle\n    }),\n        parse = _qsaObserver.parse;\n\n    var override = null;\n\n    var whenDefined = function whenDefined(name) {\n      if (!defined.has(name)) {\n        var _,\n            $ = new Lie(function ($) {\n          _ = $;\n        });\n\n        defined.set(name, {\n          $: $,\n          _: _\n        });\n      }\n\n      return defined.get(name).$;\n    };\n\n    var augment = attributesObserver(whenDefined, MutationObserver$1);\n    defineProperty(self, 'customElements', {\n      configurable: true,\n      value: {\n        define: function define(is, Class) {\n          if (registry.has(is)) throw new Error(\"the name \\\"\".concat(is, \"\\\" has already been used with this registry\"));\n          classes.set(Class, is);\n          prototypes.set(is, Class.prototype);\n          registry.set(is, Class);\n          query.push(is);\n          whenDefined(is).then(function () {\n            parse(document$1.querySelectorAll(is));\n          });\n\n          defined.get(is)._(Class);\n        },\n        get: function get(is) {\n          return registry.get(is);\n        },\n        whenDefined: whenDefined\n      }\n    });\n    defineProperty(HTMLBuiltIn.prototype = HTMLElement.prototype, 'constructor', {\n      value: HTMLBuiltIn\n    });\n    defineProperty(self, 'HTMLElement', {\n      configurable: true,\n      value: HTMLBuiltIn\n    });\n    defineProperty(document$1, 'createElement', {\n      configurable: true,\n      value: function value(name, options) {\n        var is = options && options.is;\n        var Class = is ? registry.get(is) : registry.get(name);\n        return Class ? new Class() : createElement.call(document$1, name);\n      }\n    }); // in case ShadowDOM is used through a polyfill, to avoid issues\n    // with builtin extends within shadow roots\n\n    if (!('isConnected' in Node.prototype)) defineProperty(Node.prototype, 'isConnected', {\n      configurable: true,\n      get: function get() {\n        return !(this.ownerDocument.compareDocumentPosition(this) & this.DOCUMENT_POSITION_DISCONNECTED);\n      }\n    });\n  } else {\n    try {\n      var LI = function LI() {\n        return self.Reflect.construct(HTMLLIElement, [], LI);\n      };\n\n      LI.prototype = HTMLLIElement.prototype;\n      var is = 'extends-li';\n      self.customElements.define('extends-li', LI, {\n        'extends': 'li'\n      });\n      legacy = document$1.createElement('li', {\n        is: is\n      }).outerHTML.indexOf(is) < 0;\n      var _self$customElements = self.customElements,\n          get = _self$customElements.get,\n          _whenDefined = _self$customElements.whenDefined;\n      defineProperty(self.customElements, 'whenDefined', {\n        configurable: true,\n        value: function value(is) {\n          var _this = this;\n\n          return _whenDefined.call(this, is).then(function (Class) {\n            return Class || get.call(_this, is);\n          });\n        }\n      });\n    } catch (o_O) {\n      legacy = !legacy;\n    }\n  }\n\n  if (legacy) {\n    var parseShadow = function parseShadow(element) {\n      var root = shadowRoots.get(element);\n\n      _parse(root.querySelectorAll(this), element.isConnected);\n    };\n\n    var customElements = self.customElements;\n    var attachShadow = Element.prototype.attachShadow;\n    var _createElement = document$1.createElement;\n    var define = customElements.define,\n        _get = customElements.get;\n\n    var _ref = Reflect || {\n      construct: function construct(HTMLElement) {\n        return HTMLElement.call(this);\n      }\n    },\n        construct = _ref.construct;\n\n    var shadowRoots = new WeakMap();\n    var shadows = new Set$1();\n\n    var _classes = new Map();\n\n    var _defined = new Map();\n\n    var _prototypes = new Map();\n\n    var _registry = new Map();\n\n    var shadowed = [];\n    var _query = [];\n\n    var getCE = function getCE(is) {\n      return _registry.get(is) || _get.call(customElements, is);\n    };\n\n    var _handle = function _handle(element, connected, selector) {\n      var proto = _prototypes.get(selector);\n\n      if (connected && !proto.isPrototypeOf(element)) {\n        var redefine = expando(element);\n        _override = setPrototypeOf(element, proto);\n\n        try {\n          new proto.constructor();\n        } finally {\n          _override = null;\n          redefine();\n        }\n      }\n\n      var method = \"\".concat(connected ? '' : 'dis', \"connectedCallback\");\n      if (method in proto) element[method]();\n    };\n\n    var _qsaObserver2 = qsaObserver({\n      query: _query,\n      handle: _handle\n    }),\n        _parse = _qsaObserver2.parse;\n\n    var _qsaObserver3 = qsaObserver({\n      query: shadowed,\n      handle: function handle(element, connected) {\n        if (shadowRoots.has(element)) {\n          if (connected) shadows.add(element);else shadows[\"delete\"](element);\n          if (_query.length) parseShadow.call(_query, element);\n        }\n      }\n    }),\n        parseShadowed = _qsaObserver3.parse;\n\n    var _whenDefined2 = function _whenDefined2(name) {\n      if (!_defined.has(name)) {\n        var _,\n            $ = new Promise$1(function ($) {\n          _ = $;\n        });\n\n        _defined.set(name, {\n          $: $,\n          _: _\n        });\n      }\n\n      return _defined.get(name).$;\n    };\n\n    var _augment = attributesObserver(_whenDefined2, MutationObserver$1);\n\n    var _override = null;\n    getOwnPropertyNames(self).filter(function (k) {\n      return /^HTML/.test(k);\n    }).forEach(function (k) {\n      var HTMLElement = self[k];\n\n      function HTMLBuiltIn() {\n        var constructor = this.constructor;\n        if (!_classes.has(constructor)) throw new TypeError('Illegal constructor');\n\n        var _classes$get = _classes.get(constructor),\n            is = _classes$get.is,\n            tag = _classes$get.tag;\n\n        if (is) {\n          if (_override) return _augment(_override, is);\n\n          var element = _createElement.call(document$1, tag);\n\n          element.setAttribute('is', is);\n          return _augment(setPrototypeOf(element, constructor.prototype), is);\n        } else return construct.call(this, HTMLElement, [], constructor);\n      }\n\n\n      defineProperty(HTMLBuiltIn.prototype = HTMLElement.prototype, 'constructor', {\n        value: HTMLBuiltIn\n      });\n      defineProperty(self, k, {\n        value: HTMLBuiltIn\n      });\n    });\n    defineProperty(document$1, 'createElement', {\n      configurable: true,\n      value: function value(name, options) {\n        var is = options && options.is;\n\n        if (is) {\n          var Class = _registry.get(is);\n\n          if (Class && _classes.get(Class).tag === name) return new Class();\n        }\n\n        var element = _createElement.call(document$1, name);\n\n        if (is) element.setAttribute('is', is);\n        return element;\n      }\n    });\n    if (attachShadow) Element.prototype.attachShadow = function (init) {\n      var root = attachShadow.call(this, init);\n      shadowRoots.set(this, root);\n      return root;\n    };\n    defineProperty(customElements, 'get', {\n      configurable: true,\n      value: getCE\n    });\n    defineProperty(customElements, 'whenDefined', {\n      configurable: true,\n      value: _whenDefined2\n    });\n    defineProperty(customElements, 'define', {\n      configurable: true,\n      value: function value(is, Class, options) {\n        if (getCE(is)) throw new Error(\"'\".concat(is, \"' has already been defined as a custom element\"));\n        var selector;\n        var tag = options && options[\"extends\"];\n\n        _classes.set(Class, tag ? {\n          is: is,\n          tag: tag\n        } : {\n          is: '',\n          tag: is\n        });\n\n        if (tag) {\n          selector = \"\".concat(tag, \"[is=\\\"\").concat(is, \"\\\"]\");\n\n          _prototypes.set(selector, Class.prototype);\n\n          _registry.set(is, Class);\n\n          _query.push(selector);\n        } else {\n          define.apply(customElements, arguments);\n          shadowed.push(selector = is);\n        }\n\n        _whenDefined2(is).then(function () {\n          if (tag) {\n            _parse(document$1.querySelectorAll(selector));\n\n            shadows.forEach(parseShadow, [selector]);\n          } else parseShadowed(document$1.querySelectorAll(selector));\n        });\n\n        _defined.get(is)._(Class);\n      }\n    });\n  }\n\n}());\n", "// See implementation notes in `impl.md`.\n\n/** Bool **/\n\nexport function truthy(val)        {return Boolean(val)}\nexport function falsy(val)         {return !val}\nexport function is(a, b)           {return a === b || (isNaN(a) && isNaN(b))}\nexport function isNil(val)         {return val == null}\nexport function isSome(val)        {return !isNil(val)}\nexport function isBool(val)        {return typeof val === 'boolean'}\nexport function isNum(val)         {return typeof val === 'number'}\nexport function isFin(val)         {return isNum(val) && !isNaN(val) && !isInf(val)}\nexport function isInt(val)         {return isNum(val) && ((val % 1) === 0)}\nexport function isNat(val)         {return isInt(val) && val >= 0}\nexport function isNatPos(val)      {return isInt(val) && val > 0}\nexport function isNaN(val)         {return val !== val} // eslint-disable-line no-self-compare\nexport function isInf(val)         {return val === Infinity || val === -Infinity}\nexport function isStr(val)         {return typeof val === 'string'}\nexport function isKey(val)         {return isStr(val) || isSym(val) || isBool(val) || isFin(val)}\nexport function isPrim(val)        {return !isComp(val)}\nexport function isComp(val)        {return isObj(val) || isFun(val)}\nexport function isFun(val)         {return typeof val === 'function'}\nexport function isObj(val)         {return val !== null && typeof val === 'object'}\nexport function isStruct(val)      {return isObj(val) && !isList(val) && !isInst(val, String)}\nexport function isArr(val)         {return isInst(val, Array)}\nexport function isReg(val)         {return isInst(val, RegExp)}\nexport function isSym(val)         {return typeof val === 'symbol'}\nexport function isDate(val)        {return isInst(val, Date)}\nexport function isValidDate(val)   {return isDate(val) && isFin(val.valueOf())}\nexport function isInvalidDate(val) {return isDate(val) && !isValidDate(val)}\nexport function isPromise(val)     {return isComp(val) && isFun(val.then) && isFun(val.catch)}\nexport function isCls(val)         {return isFun(val) && typeof val.prototype === 'object'}\n\nexport function isInst(val, Cls) {\n  req(Cls, isCls)\n  return isComp(val) && val instanceof Cls\n}\n\nexport function isDict(val) {\n  if (!isObj(val)) return false\n  const proto = Object.getPrototypeOf(val)\n  return proto === null || proto === Object.prototype\n}\n\nexport function isList(val) {\n  if (!isObj(val))                 return false\n  if (isArr(val))                  return true\n  if (!isNat(val.length))          return false\n  if (isDict(val))                 return hasOwn(val, 'callee')\n  if (isInst(val, String))         return false\n  if (isFun(val.forEach))          return true\n  if (isFun(val[Symbol.iterator])) return true\n  return false\n}\n\nexport function isIter(val) {\n  return isObj(val) && isFun(val.next) && isFun(val.return) && isFun(val.throw)\n}\n\nexport function isOpt(val, fun, ...args) {\n  req(fun, isFun)\n  return isNil(val) || truthy(fun(val, ...args))\n}\n\nexport function hasOwn(val, key) {\n  req(key, isKey)\n  return isComp(val) && Object.prototype.hasOwnProperty.call(val, key)\n}\n\nexport function testBy(val, pattern) {\n  return (\n    isFun(pattern)    ? truthy(pattern(val)) :\n    isPrim(pattern)   ? is(val, pattern) :\n    isReg(pattern)    ? isStr(val) && pattern.test(val) :\n    isDate(pattern)   ? isDate(val) && is(pattern.valueOf(), val.valueOf()) :\n    isList(pattern)   ? isList(val) && every(pattern, testAt, val) :\n    isStruct(pattern) ? isStruct(val) && everyVal(pattern, testAt, val) :\n    false\n  )\n}\n\nfunction testAt(pattern, key, val) {return testBy(val[key], pattern)}\n\nexport function test(pattern) {\n  return function test_(val) {return testBy(val, pattern)}\n}\n\n// Internal for now.\nfunction isNatOrInf(val) {return isNat(val) || isInf(val)}\n\n/** Opt Conversions **/\n\nexport function prim(val)   {return isNil(val) ? undefined : req(val, isPrim)}\nexport function bool(val)   {return isNil(val) ? false     : req(val, isBool)}\nexport function num(val)    {return isNil(val) ? 0         : req(val, isNum)}\nexport function fin(val)    {return isNil(val) ? 0         : req(val, isFin)}\nexport function int(val)    {return isNil(val) ? 0         : req(val, isInt)}\nexport function nat(val)    {return isNil(val) ? 0         : req(val, isNat)}\nexport function natPos(val) {return isNil(val) ? 0         : req(val, isNatPos)}\nexport function str(val)    {return isNil(val) ? ''        : req(val, isStr)}\nexport function list(val)   {return isNil(val) ? []        : req(val, isList)}\nexport function arr(val)    {return isNil(val) ? []        : req(val, isArr)}\nexport function dict(val)   {return isNil(val) ? {}        : req(val, isDict)}\nexport function struct(val) {return isNil(val) ? {}        : req(val, isStruct)}\nexport function comp(val)   {return isNil(val) ? {}        : req(val, isComp)}\n\n/** Cross-Type Conversions **/\n\nexport function toStr(val) {return isNil(val) ? '' : String(prim(val))}\nexport function toArr(val) {return isArr(val) ? val : slice(val)}\n\n/** Assertions **/\n\nexport function req(val, test, ...args) {\n  if (!isFun(test, ...args)) {\n    throw TypeError(`expected reqator function, got ${show(test)}`)\n  }\n  if (!test(val)) {\n    throw TypeError(`expected ${show(val)} to satisfy test ${show(test)}`)\n  }\n  return val\n}\n\nexport function opt(val, test, ...args) {\n  req(test, isFun)\n  return isNil(val) ? val : req(val, test, ...args)\n}\n\nexport function reqInst(val, Cls) {\n  if (!isInst(val, Cls)) {\n    const cons = isComp(val) ? val.constructor : undefined\n    throw TypeError(`expected ${show(val)}${cons ? ` (instance of ${show(cons)})` : ``} to be an instance of ${show(Cls)}`)\n  }\n  return val\n}\n\nexport function optInst(val, Cls) {\n  req(Cls, isFun)\n  return isNil(val) ? val : reqInst(val, Cls)\n}\n\nexport function reqEach(val, test, ...args) {\n  req(test, isFun)\n  each(val, reqAt, test, ...args)\n  return val\n}\n\nexport function reqEachVal(val, test, ...args) {\n  req(test, isFun)\n  eachVal(val, reqAt, test, ...args)\n  return val\n}\n\n/** Fun **/\n\nexport function call(fun, ...args) {return fun.apply(this, args)}\nexport function apply(fun, args)   {return fun.apply(this, args)}\nexport function bind(fun, ...args) {return fun.bind(this, ...args)}\n\nexport function not(fun) {\n  req(fun, isFun)\n  return function not_() {return !fun.apply(this, arguments)}\n}\n\n// Short for \"call without key\".\nexport function cwk(val, _key, fun, ...args) {return fun(val, ...args)}\n\n/** Misc **/\n\nexport function vac(val) {return val || undefined}\nexport function True() {return true}\nexport function False() {return false}\n\n/** List **/\n\nexport function len(val)    {return isNil(val) ? 0 : list(val).length}\nexport function hasLen(val) {return isList(val) && truthy(val.length)}\nexport function vacate(val) {return hasLen(val) ? val : undefined}\n\nexport function each(val, fun, ...args) {\n  val = list(val)\n  req(fun, isFun)\n  for (let i = 0; i < val.length; i++) fun(val[i], i, ...args)\n}\n\nexport function map(val, fun, ...args) {\n  return mapMut(slice(val), fun, ...args)\n}\n\nexport function mapMut(val, fun, ...args) {\n  req(val, isList)\n  req(fun, isFun)\n  for (let i = 0; i < val.length; i++) val[i] = fun(val[i], i, ...args)\n  return val\n}\n\nexport function mapFlat(val, fun, ...args) {\n  return flat(map(val, fun, ...args))\n}\n\nexport function mapFlatDeep(val, fun, ...args) {\n  return flatDeep(map(val, fun, ...args))\n}\n\nexport function mapFilter(val, fun, ...args) {\n  return compact(map(val, fun, ...args))\n}\n\nexport function filter(val, fun, ...args) {\n  val = list(val)\n  req(fun, isFun)\n  const out = []\n  for (let i = 0; i < val.length; i++) {\n    const elem = val[i]\n    if (fun(elem, i, ...args)) out.push(elem)\n  }\n  return out\n}\n\nexport function reject(val, fun, ...args) {\n  req(fun, isFun)\n  return filter(val, notBy, fun, ...args)\n}\n\nfunction notBy(val, key, fun, ...args) {\n  return !fun(val, key, ...args)\n}\n\nexport function fold(val, acc, fun, ...args) {\n  val = list(val)\n  req(fun, isFun)\n  for (let i = 0; i < val.length; i++) acc = fun(acc, val[i], i, ...args)\n  return acc\n}\n\nexport function foldRight(val, acc, fun, ...args) {\n  val = list(val)\n  req(fun, isFun)\n  for (let i = val.length - 1; i >= 0; i--) acc = fun(acc, val[i], i, ...args)\n  return acc\n}\n\nexport function fold1(val, fun, ...args) {\n  val = list(val)\n  req(fun, isFun)\n  let acc = val[0]\n  for (let i = 1; i < val.length; i++) acc = fun(acc, val[i], i, ...args)\n  return acc\n}\n\nexport function compact(val) {return filter(val, id)}\n\nexport function find(val, fun, ...args) {\n  val = list(val)\n  req(fun, isFun)\n  return val[findIndex(val, fun, ...args)]\n}\n\nexport function findRight(val, fun, ...args) {\n  val = list(val)\n  req(fun, isFun)\n  return val[findIndexRight(val, fun, ...args)]\n}\n\nexport function findIndex(val, fun, ...args) {\n  val = list(val)\n  req(fun, isFun)\n  for (let i = 0; i < val.length; i++) {\n    if (fun(val[i], i, ...args)) return i\n  }\n  return -1\n}\n\nexport function findIndexRight(val, fun, ...args) {\n  val = list(val)\n  req(fun, isFun)\n  for (let i = val.length; --i >= 0;) {\n    if (fun(val[i], i, ...args)) return i\n  }\n  return -1\n}\n\nexport function indexOf(val, elem) {\n  return findIndex(val, isAt, elem)\n}\n\nexport function lastIndexOf(val, elem) {\n  return findIndexRight(val, isAt, elem)\n}\n\nfunction isAt(candidate, _i, val) {\n  return is(candidate, val)\n}\n\nexport function includes(val, elem) {\n  return indexOf(val, elem) !== -1\n}\n\nexport function procure(val, fun, ...args) {\n  val = list(val)\n  req(fun, isFun)\n  for (let i = 0; i < val.length; i++) {\n    const res = fun(val[i], i, ...args)\n    if (res) return res\n  }\n  return undefined\n}\n\nexport function every(val, fun, ...args) {\n  val = list(val)\n  req(fun, isFun)\n  for (let i = 0; i < val.length; i++) {\n    if (!fun(val[i], i, ...args)) return false\n  }\n  return true\n}\n\nexport function some(val, fun, ...args) {\n  val = list(val)\n  req(fun, isFun)\n  for (let i = 0; i < val.length; i++) {\n    if (fun(val[i], i, ...args)) return true\n  }\n  return false\n}\n\nexport function slice(val, start, next) {\n  return Array.prototype.slice.call(list(val), start, next)\n}\n\nexport function append(val, elem) {\n  return toArr(val).concat([elem])\n}\n\nexport function prepend(val, elem) {\n  return [elem].concat(toArr(val))\n}\n\nexport function remove(val, elem) {\n  return removeAt(val, indexOf(val, elem))\n}\n\nexport function adjoin(val, elem) {\n  return includes(val, elem) ? toArr(val) : append(val, elem)\n}\n\nexport function toggle(val, elem) {\n  return includes(val, elem) ? remove(val, elem) : append(val, elem)\n}\n\nexport function insertAt(val, ind, elem) {\n  val = slice(val)\n  reqBounded(val.length, ind)\n  val.splice(ind, 0, elem)\n  return val\n}\n\nexport function replaceAt(val, ind, elem) {\n  val = slice(val)\n  req(ind, isNat)\n  val[ind] = elem\n  return val\n}\n\nfunction reqBounded(len, ind) {\n  req(ind, isNat)\n  if (!(ind <= len)) {\n    throw Error(`index ${ind} out of bounds for length ${len}`)\n  }\n}\n\nexport function removeAt(val, ind) {\n  val = list(val)\n  req(ind, isInt)\n  if (isNat(ind) && ind < val.length) {\n    val = slice(val)\n    val.splice(ind, 1)\n  }\n  return val\n}\n\n// Uses native concat because it seems to perform very well in many JS engines.\nexport function concat(...args) {\n  return [].concat(...mapMut(args, toArr))\n}\n\nexport function flat(val) {\n  const out = []\n  each(val, pushFlat, out)\n  return out\n}\n\nfunction pushFlat(val, _i, out) {\n  if (isList(val)) for (let i = 0; i < val.length; i++) out.push(val[i])\n  else out.push(val)\n}\n\nexport function flatDeep(val) {\n  const out = []\n  each(val, pushFlatDeep, out)\n  return out\n}\n\nfunction pushFlatDeep(val, _key, out) {\n  if (isList(val)) each(val, pushFlatDeep, out)\n  else out.push(val)\n}\n\nexport function head(val) {\n  return list(val)[0]\n}\n\nexport function tail(val) {\n  return slice(val, 1)\n}\n\nexport function init(val) {\n  val = list(val)\n  return slice(val, 0, val.length - 1)\n}\n\nexport function last(val) {\n  val = list(val)\n  return val[val.length - 1]\n}\n\nexport function take(val, count) {\n  req(count, isNatOrInf)\n  return slice(val, 0, count)\n}\n\nexport function takeWhile(val, fun, ...args) {\n  req(fun, isFun)\n  const ind = findIndex(val, notBy, fun, ...args)\n  return isNat(ind) ? slice(val, 0, ind) : list(val)\n}\n\nexport function drop(val, count) {\n  req(count, isNatOrInf)\n  return slice(val, count)\n}\n\nexport function dropWhile(val, fun, ...args) {\n  req(fun, isFun)\n  const ind = findIndex(val, notBy, fun, ...args)\n  return isNat(ind) ? slice(val, ind) : []\n}\n\nexport function count(val, fun, ...args) {\n  req(fun, isFun)\n  return fold(val, 0, incIf, fun, ...args)\n}\n\nfunction incIf(acc, val, i, fun, ...args) {\n  return fun(val, i, ...args) ? acc + 1 : acc\n}\n\nexport function countWhile(val, fun, ...args) {\n  req(fun, isFun)\n  const ind = findIndex(val, notBy, fun, ...args)\n  return isNat(ind) ? ind : len(val)\n}\n\nexport function times(count, fun, ...args) {\n  req(fun, isFun)\n  req(count, isNat)\n  const out = Array(count)\n  for (let i = 0; i < count; i++) out[i] = fun(i, ...args)\n  return out\n}\n\nexport function reverse(val) {\n  val = list(val)\n  const len = val.length\n  const out = Array(len)\n  for (let i = len; --i >= 0;) out[len - i - 1] = val[i]\n  return out\n}\n\nexport function sort(val, comparator) {\n  return slice(val).sort(comparator)\n}\n\nexport function sortBy(val, fun, ...args) {\n  req(fun, isFun)\n  return sort(val, function compareBy(left, right) {\n    return sortCompare(fun(left, ...args), fun(right, ...args))\n  })\n}\n\n// https://tc39.github.io/ecma262/#sec-sortcompare\nexport function sortCompare(left, right) {\n  if (left === undefined && right === undefined) return 0\n  if (left === undefined) return 1\n  if (right === undefined) return -1\n  left = String(left)\n  right = String(right)\n  if (left < right) return -1\n  if (right < left) return 1\n  return 0\n}\n\nexport function intersect(left, right) {\n  left = list(left)\n  right = list(right)\n  const lr = left.length <= right.length\n  const lesser = lr ? left : right\n  const greater = lr ? right : left\n  const out = []\n  each(greater, intersectAdd, out, lesser)\n  return out\n}\n\nfunction intersectAdd(val, _key, out, control) {\n  if (includes(control, val) && !includes(out, val)) out.push(val)\n}\n\nexport function keyBy(val, fun, ...args) {\n  val = list(val)\n  req(fun, isFun)\n  const out = {}\n  for (let i = 0; i < val.length; i++) {\n    const elem = val[i]\n    const key = fun(elem, i, ...args)\n    if (isKey(key)) out[key] = elem\n  }\n  return out\n}\n\nexport function groupBy(val, fun, ...args) {\n  val = list(val)\n  req(fun, isFun)\n  const out = {}\n  for (let i = 0; i < val.length; i++) {\n    const elem = val[i]\n    const groupKey = fun(elem, i, ...args)\n    if (isKey(groupKey)) {\n      if (!hasOwn(out, groupKey)) out[groupKey] = []\n      out[groupKey].push(elem)\n    }\n  }\n  return out\n}\n\nexport function uniq(val) {\n  return uniqBy(val, id)\n}\n\nexport function uniqBy(val, fun, ...args) {\n  val = list(val)\n  req(fun, isFun)\n  const out = []\n  const attrs = []\n  for (let i = 0; i < val.length; i++) {\n    const elem = val[i]\n    const attr = fun(elem, i, ...args)\n    if (!includes(attrs, attr)) {\n      attrs.push(attr)\n      out.push(elem)\n    }\n  }\n  return out\n}\n\nexport function partition(val, fun, ...args) {\n  val = list(val)\n  req(fun, isFun)\n  const accepted = []\n  const rejected = []\n  for (let i = 0; i < val.length; i++) {\n    const elem = val[i]\n    if (fun(elem, i, ...args)) accepted.push(elem)\n    else rejected.push(elem)\n  }\n  return [accepted, rejected]\n}\n\nexport function sum(val) {\n  return sumBy(val, id)\n}\n\nexport function sumBy(val, fun, ...args) {\n  req(fun, isFun)\n  return fold(val, 0, maybeAddBy, fun, ...args)\n}\n\nfunction maybeAddBy(acc, val, i, fun, ...args) {\n  val = fun(val, i, ...args)\n  return isFin(val) ? acc + val : acc\n}\n\nexport function min(val) {\n  return minBy(val, id)\n}\n\nexport function max(val) {\n  return maxBy(val, id)\n}\n\nexport function minBy(val, fun, ...args) {\n  req(fun, isFun)\n  return fold(val, undefined, compareNumsBy, lt, fun, ...args)\n}\n\nexport function maxBy(val, fun, ...args) {\n  req(fun, isFun)\n  return fold(val, undefined, compareNumsBy, gt, fun, ...args)\n}\n\nfunction compareNumsBy(acc, val, key, compare, fun, ...args) {\n  val = fun(val, key, ...args)\n  return !isFin(val)\n    ? acc\n    : !isFin(acc) || compare(val, acc)\n    ? val\n    : acc\n}\n\nexport function findMinBy(val, fun, ...args) {\n  req(fun, isFun)\n  return findNumBy(val, lt, fun, ...args)\n}\n\nexport function findMaxBy(val, fun, ...args) {\n  req(fun, isFun)\n  return findNumBy(val, gt, fun, ...args)\n}\n\n// WTF too large!\nfunction findNumBy(val, compare, fun, ...args) {\n  val = list(val)\n  req(compare, isFun)\n  req(fun, isFun)\n  let winningValue = undefined\n  let winningAttr = undefined\n  for (let i = 0; i < val.length; i++) {\n    const elem = val[i]\n    const attr = fun(elem, i, ...args)\n    if (isFin(attr) && (isNil(winningAttr) || compare(attr, winningAttr))) {\n      winningValue = elem\n      winningAttr = attr\n    }\n  }\n  return winningValue\n}\n\nexport function range(start, end) {\n  req(start, isInt)\n  req(end, isInt)\n  let remaining = end - start\n  // Note: this rejects negatives, producing a decent error message.\n  const out = Array(remaining)\n  while (--remaining >= 0) out[remaining] = start + remaining\n  return out\n}\n\nexport function zip(entries) {\n  return fold(entries, {}, zipAdd)\n}\n\nfunction zipAdd(acc, pair) {\n  req(pair, isList)\n  const key = pair[0]\n  if (!isNil(key)) acc[req(key, isKey)] = pair[1]\n  return acc\n}\n\n/** Struct **/\n\nexport function size(val)    {return keys(val).length}\nexport function keys(val)    {return Object.keys(struct(val))}\nexport function vals(val)    {return Object.values(struct(val))}\nexport function entries(val) {return Object.entries(struct(val))}\nexport function hasSize(val) {return isStruct(val) && truthy(size(val))}\n\nexport function eachVal(val, fun, ...args) {\n  val = struct(val)\n  req(fun, isFun)\n  for (const key in val) fun(val[key], key, ...args)\n}\n\nexport function foldVals(val, acc, fun, ...args) {\n  val = struct(val)\n  req(fun, isFun)\n  for (const key in val) acc = fun(acc, val[key], key, ...args)\n  return acc\n}\n\nexport function mapVals(val, fun, ...args) {\n  return mapValsMut(assign({}, val), fun, ...args)\n}\n\nexport function mapValsMut(val, fun, ...args) {\n  req(val, isStruct)\n  req(fun, isFun)\n  for (const key in val) val[key] = fun(val[key], key, ...args)\n  return val\n}\n\nexport function mapKeys(val, fun, ...args) {\n  val = struct(val)\n  req(fun, isFun)\n\n  const out = {}\n  for (let key in val) {\n    const elem = val[key]\n    key = fun(key, elem, ...args)\n    if (isKey(key)) out[key] = elem\n  }\n  return out\n}\n\nexport function mapValsSort(val, fun, ...args) {\n  val = struct(val)\n  req(fun, isFun)\n\n  const out = keys(val).sort()\n  for (let i = 0; i < out.length; i++) {\n    const key = out[i]\n    out[i] = fun(val[key], key, ...args)\n  }\n  return out\n}\n\nexport function pick(val, fun, ...args) {\n  val = struct(val)\n  req(fun, isFun)\n\n  const out = {}\n  for (const key in val) {\n    const elem = val[key]\n    if (fun(elem, key, ...args)) out[key] = elem\n  }\n  return out\n}\n\nexport function omit(val, fun, ...args) {\n  req(fun, isFun)\n  return pick(val, notBy, fun, ...args)\n}\n\nexport function pickKeys(val, keys) {\n  return fold(keys, {}, pickKnown, struct(val))\n}\n\nfunction pickKnown(tar, key, _i, src) {\n  if (hasOwn(src, key)) tar[key] = src[key]\n  return tar\n}\n\nexport function omitKeys(val, keys) {\n  return fold(keys, mut({}, val), deleteKnown)\n}\n\nfunction deleteKnown(tar, key) {\n  delete tar[key]\n  return tar\n}\n\nexport function findVal(val, fun, ...args) {\n  val = struct(val)\n  req(fun, isFun)\n\n  for (const key in val) {\n    const elem = val[key]\n    if (fun(elem, key, ...args)) return elem\n  }\n  return undefined\n}\n\nexport function findKey(val, fun, ...args) {\n  val = struct(val)\n  req(fun, isFun)\n  const inputKeys = keys(val)\n  for (let i = 0; i < inputKeys.length; i++) {\n    const key = inputKeys[i]\n    if (fun(val[key], key, ...args)) return key\n  }\n  return undefined\n}\n\nexport function everyVal(val, fun, ...args) {\n  val = struct(val)\n  req(fun, isFun)\n  for (const key in val) if (!fun(val[key], key, ...args)) return false\n  return true\n}\n\nexport function someVal(val, fun, ...args) {\n  val = struct(val)\n  req(fun, isFun)\n  const inputKeys = keys(val)\n  for (let i = 0; i < inputKeys.length; i++) {\n    const key = inputKeys[i]\n    if (fun(val[key], key, ...args)) return true\n  }\n  return false\n}\n\nexport function invert(val) {\n  return invertBy(val, id)\n}\n\nexport function invertBy(val, fun, ...args) {\n  val = struct(val)\n  req(fun, isFun)\n  const out = {}\n  const inputKeys = keys(val)\n  for (let i = 0; i < inputKeys.length; i++) {\n    const key = inputKeys[i]\n    const newKey = fun(val[key], key, ...args)\n    if (isKey(newKey)) out[newKey] = key\n  }\n  return out\n}\n\n/** Ops **/\n\nexport function neg(a)    {return -a}\nexport function add(a, b) {return a + b}\nexport function sub(a, b) {return a - b}\nexport function mul(a, b) {return a * b}\nexport function div(a, b) {return a / b}\nexport function rem(a, b) {return a % b}\nexport function lt(a, b)  {return a < b}\nexport function gt(a, b)  {return a > b}\nexport function lte(a, b) {return a <= b}\nexport function gte(a, b) {return a >= b}\nexport function inc(a)    {return a + 1}\nexport function dec(a)    {return a - 1}\n\n/** Misc **/\n\n// The \"pure\" annotation allows minifiers to drop this if the var is unused.\n// eslint-disable-next-line no-new-func\nexport const global = /* #__PURE__ */Function('return this')()\n\nexport function nop()        {}\nexport function id(val)      {return val}\nexport function di(_, val)   {return val}\nexport function val(val)     {return bind(id, val)}\nexport function rethrow(val) {throw val}\n\nexport function get(val, key) {\n  req(key, isKey)\n  return isComp(val) ? val[key] : undefined\n}\n\nexport function scan(val, ...path) {return fold(path, val, get)}\nexport function getIn(val, path) {return fold(path, val, get)}\n\nexport function getter(key) {\n  req(key, isKey)\n  return function get_(val) {return get(val, key)}\n}\n\nexport function assign(tar, ...args) {return fold(args, req(tar, isComp), mut)}\n\nfunction mut(tar, src) {\n  src = struct(src)\n  for (const key in src) tar[key] = src[key]\n  return tar\n}\n\nfunction reqAt(val, key, test, ...args) {\n  if (!test(val, ...args)) {\n    throw TypeError(`expected ${show(val)} at key ${key} to satisfy test ${show(test)}`)\n  }\n}\n\nexport function show(val) {\n  if (isFun(val) && val.name) return val.name\n\n  // Plain data becomes JSON, if possible.\n  if (isArr(val) || isDict(val) || isStr(val)) {\n    try {return JSON.stringify(val)}\n    catch (_) {return String(val)}\n  }\n\n  return String(val)\n}\n", "/// <reference types=\"./dom.d.ts\" />\n// See `impl.md` for implementation notes.\n\n/* Public API */\n\nexport function E(name, props, ...children) {\n  elemValid(name, children)\n  const node = document.createElement(name, props)\n  return initNode(node, props, children)\n}\n\nexport function S(name, props, ...children) {\n  valid(name, isStr)\n  const node = document.createElementNS(`http://www.w3.org/2000/svg`, name, props)\n  return initNode(node, props, children)\n}\n\nexport function F(...children) {\n  return appendChildren(new DocumentFragment(), children)\n}\n\nexport function reset(node, props, ...children) {\n  resetProps(node, props)\n  return resetChildren(node, children)\n}\n\nexport function resetProps(node, props) {\n  validInst(node, Element)\n  eachVal(props, setProp, node)\n  return node\n}\n\nexport function replace(node, ...children) {\n  node.parentNode.replaceChild(F(...children), node)\n}\n\nexport function props(node) {\n  validInst(node, Element)\n  return fold(node.attributes, {dataset: node.dataset}, attrToProp, node)\n}\n\nexport function cls(...vals) {\n  return fold(vals, '', clsAppend)\n}\n\nexport function len(val) {\n  return isNil(val) ? 0 : isArr(val) ? sumBy(val, len) : 1\n}\n\nexport function vac(val) {return hasSome(val) ? val : undefined}\n\nexport function map(val, fun, ...args) {\n  valid(fun, isFun)\n  const acc = []\n  mapMutDeep(0, val, 0, acc, fun, ...args)\n  return acc\n}\n\n// Shim for isomorphism with `str.mjs`.\nexport function doc(val) {return val}\n\n// The specification postulates the concept, but where's the standard list?\n// Taken from non-authoritative sources.\n//\n// https://www.w3.org/TR/html52/infrastructure.html#boolean-attribute\nexport const boolAttrs = /* @__PURE__ */ new Set([\n  'allowfullscreen', 'allowpaymentrequest', 'async',    'autofocus',\n  'autoplay',        'checked',             'controls', 'default',\n  'disabled',        'formnovalidate',      'hidden',   'ismap',\n  'itemscope',       'loop',                'multiple', 'muted',\n  'nomodule',        'novalidate',          'open',     'playsinline',\n  'readonly',        'required',            'reversed', 'selected',\n  'truespeed',\n])\n\n// https://www.w3.org/TR/html52/\n// https://www.w3.org/TR/html52/syntax.html#writing-html-documents-elements\nexport const voidElems = /* @__PURE__ */ new Set([\n  'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta',\n  'param', 'source', 'track', 'wbr',\n])\n\n// Makes user code more explicit/intentional. In reality, any `new String`\n// object serves as a \"raw\" marker.\nexport class Raw extends String {}\n\nexport function e(...args) {return E.bind(undefined, ...args)}\n\n/* Internal Utils */\n\nfunction initNode(node, props, children) {\n  resetProps(node, props)\n  return appendChildren(node, children)\n}\n\nfunction resetChildren(node, children) {\n  if (!children.length) {\n    removeNodes(node)\n    return node\n  }\n\n  // See `impl.md`.\n  const frag = F(...children)\n  removeNodes(node)\n  node.append(frag)\n  return node\n}\n\nfunction removeNodes(node) {\n  validInst(node, Node)\n  while (node.firstChild) node.firstChild.remove()\n}\n\nfunction appendChildren(node, children) {\n  children.forEach(appendChildTo, node)\n  return node\n}\n\nfunction appendChildTo(child) {appendChild(this, child)}\n\nfunction appendChild(node, val) {\n  if (isNil(val))          return\n  if (val === '')          return\n  if (isInst(val, Node))   return void node.append(val)\n  if (isInst(val, String)) return void appendRawChild(node, val)\n  if (isArr(val))          return void appendChildren(node, val)\n  node.append(toStr(val))\n}\n\n// Probably inefficient. Might be better solutions, but let's benchmark first.\nfunction appendRawChild(node, val) {\n  const clone = node.cloneNode()\n  clone.innerHTML = val\n  while (clone.firstChild) node.append(clone.firstChild)\n}\n\n// Should be kept in sync with `str.mjs` -> `encodeProp`.\n// Expected to accumulate more special cases over time.\nfunction setProp(val, key, node) {\n  if (key === 'children')     throw Error(`use {R} from 'prax/rcompat.mjs' for children-in-props`)\n  if (key === 'is')           return undefined\n  if (key === 'attributes')   return void setAttrs(node, val)\n  if (key === 'class')        return void setClass(node, normStr(val))\n  if (key === 'className')    return void setClass(node, normStr(val))\n  if (key === 'style')        return void setStyle(node, val)\n  if (key === 'dataset')      return void setDataset(node, val)\n  if (/^aria[A-Z]/.test(key)) return void setAttr(val, toAria(key), node)\n  setUnknownProp(node, key, val)\n}\n\n// Careful balancing act: minimizing gotchas AND special-case knowledge. Likely\n// to get revised many, many times. Also likely one of the bottlenecks.\n//\n// For a VERY approximate inverse, see `guessProp`.\nfunction setUnknownProp(node, key, val) {\n  if (key in node) {\n    const prev = node[key]\n    if (isNil(prev) || isFun(prev)) {\n      maybeSetProp(node, key, prev, normNil(val))\n      return\n    }\n\n    if (isStr(prev)) {\n      maybeSetProp(node, key, prev, toStr(val))\n      return\n    }\n\n    if (isPrim(prev)) {\n      if (!isPrim(val)) throw Error(`can't set non-primitive \"${show(key)}\": ${show(val)} on ${show(node)}`)\n      if (!isNil(val) && boolAttrs.has(key)) validAt(key, val, isBool)\n      maybeSetProp(node, key, prev, val)\n      return\n    }\n  }\n\n  setAttr(val, key, node)\n}\n\n// Diffing sometimes avoids style/layout recalculations.\nfunction maybeSetProp(tar, key, prev, next) {\n  if (!is(prev, next)) tar[key] = next\n}\n\nfunction setAttrs(node, attrs) {\n  eachVal(attrs, setAttr, node)\n}\n\n// Should be kept in sync with `str.mjs` -> `attr`.\nfunction setAttr(val, key, node) {\n  valid(key, isStr)\n\n  if (isNil(val)) {\n    node.removeAttribute(key)\n    return\n  }\n\n  if (boolAttrs.has(key)) {\n    validAt(key, val, isBool)\n    if (val) node.setAttribute(key, '')\n    else node.removeAttribute(key)\n    return\n  }\n\n  validAt(key, val, isStringable)\n  node.setAttribute(key, toStrUnchecked(val))\n}\n\nfunction setClass(node, val) {\n  const prev = node.className\n\n  // `HTMLElement`.\n  if (isStr(prev)) {\n    maybeSetProp(node, 'className', prev, toStr(val))\n    return\n  }\n\n  // `SVGElement` and possibly others.\n  setAttr(val, 'class', node)\n}\n\n// Should be kept in sync with `str.mjs` -> `encodeStyle`.\nfunction setStyle(node, val) {\n  if (isNil(val) || isStr(val)) return setAttr(val, 'style', node)\n  if (isStruct(val)) return eachVal(val, setStyleProp, node.style)\n  throw Error(`style must be string or dict, got ${show(val)}`)\n}\n\nfunction setStyleProp(val, key, style) {\n  if (isNil(val)) val = ''\n  validAt(key, val, isStr)\n  maybeSetProp(style, key, style[key], val)\n}\n\nfunction setDataset(node, val) {\n  eachVal(val, setDatasetProp, node.dataset)\n}\n\nfunction setDatasetProp(val, key, dataset) {\n  if (isNil(val)) delete dataset[key]\n  else {\n    validAt(key, val, isStringable)\n    dataset[key] = toStrUnchecked(val)\n  }\n}\n\n// ARIA attributes appear to be case-insensitive, with only the `aria-` prefix\n// containing a hyphen.\nfunction toAria(key) {return `aria-${key.slice(4).toLowerCase()}`}\n\nfunction clsAppend(acc, val) {\n  if (isArr(val)) return fold(val, acc, clsAppend)\n\n  // For convenience, any falsy value is skipped, allowing `a && b`.\n  if (!val) return acc\n\n  val = str(val)\n  if (!acc) return val\n  return `${acc} ${val}`\n}\n\nfunction attrToProp(acc, {name, value}, _i, node) {\n  if (name.startsWith('data-')) return acc\n  acc[name] = guessProp(node, name, value)\n  return acc\n}\n\n// VERY approximate inverse of `setUnknownProp`.\nfunction guessProp(node, key, val) {\n  if (key in node) {\n    const prev = node[key]\n    if (isPrim(prev)) return prev\n  }\n  return val\n}\n\nfunction validAt(key, val, fun) {\n  if (!fun(val)) {\n    throw Error(`invalid property \"${show(key)}\": expected ${show(val)} to satisfy ${show(fun)}`)\n  }\n}\n\n// See `impl.md` on void elems.\nfunction elemValid(name, children) {\n  valid(name, isStr)\n  if (children.length && voidElems.has(name)) {\n    throw Error(`got unexpected children for void element \"${show(name)}\"`)\n  }\n}\n\n// Many DOM APIs consider only `null` to be nil.\nfunction normNil(val) {return isNil(val) ? null : val}\nfunction normStr(val) {return isNil(val) ? null : str(val)}\nfunction toStr(val) {return toStrUnchecked(valid(val, isStringable))}\n\n// WTB shorter name.\nfunction toStrUnchecked(val) {\n  if (isNil(val)) return ''\n  if (isStr(val)) return val\n  if (isPrim(val)) return val.toString()\n  return toStr(val.toString())\n}\n\nfunction isStringable(val) {return isPrim(val) || isStringableObj(val)}\n\nfunction isStringableObj(val) {\n  if (!isObj(val)) return false\n  const {toString} = val\n  return (\n    isFun(toString) &&\n    toString !== Object.prototype.toString &&\n    toString !== Array.prototype.toString\n  )\n}\n\nfunction eachVal(val, fun, ...args) {\n  if (isNil(val)) return\n  valid(val, isStruct)\n  for (const key in val) fun(val[key], key, ...args)\n}\n\nfunction fold(val, acc, fun, ...args) {\n  for (let i = 0; i < val.length; i += 1) acc = fun(acc, val[i], i, ...args)\n  return acc\n}\n\nfunction mapMutDeep(i, val, _i, acc, fun, ...args) {\n  if (isNil(val)) return i\n  if (isArr(val)) return fold(val, i, mapMutDeep, acc, fun, ...args)\n  acc.push(fun(val, i, ...args))\n  return i + 1\n}\n\nfunction sumBy(val, fun) {return fold(val, 0, addBy, fun)}\nfunction addBy(acc, val, _i, fun) {return acc + fun(val)}\n\nfunction hasSome(val) {\n  return !isNil(val) && (!isArr(val) || val.some(hasSome))\n}\n\nfunction is(a, b) {return Object.is(a, b)}\nfunction isNil(val) {return val == null}\nfunction isBool(val) {return typeof val === 'boolean'}\nfunction isStr(val) {return typeof val === 'string'}\nfunction isPrim(val) {return !isComp(val)}\nfunction isComp(val) {return isObj(val) || isFun(val)}\nfunction isFun(val) {return typeof val === 'function'}\nfunction isObj(val) {return val !== null && typeof val === 'object'}\nfunction isArr(val) {return isInst(val, Array)}\nfunction isStruct(val) {return isObj(val) && !isArr(val) && !isInst(val, String)}\nfunction isInst(val, Cls) {return isComp(val) && val instanceof Cls}\n\nfunction str(val) {return isNil(val) ? '' : valid(val, isStr)}\n\nfunction valid(val, test) {\n  if (!test(val)) throw Error(`expected ${show(val)} to satisfy test ${show(test)}`)\n  return val\n}\n\nfunction validInst(val, Cls) {\n  if (!isInst(val, Cls)) {\n    throw Error(`expected ${show(val)} to be an instance of ${show(Cls)}`)\n  }\n  return val\n}\n\n// Placeholder, might improve.\nfunction show(val) {return (isFun(val) && val.name) || String(val)}\n", "// Required for custom elements that use `is`.\nimport '@ungap/custom-elements'\n\nimport * as f from 'fpx'\nimport * as x from 'prax'\nimport {E} from 'prax'\n\nclearHash()\n\n// TODO clearer code.\nclass Carousel extends HTMLElement {\n  constructor() {\n    super()\n    this.timer = undefined\n  }\n\n  connectedCallback() {this.reset()}\n  disconnectedCallback() {this.clearTimer()}\n\n  items() {return selAll(this, `[data-carousel-item]`)}\n  index() {return f.findIndex(this.items(), f.test({hidden: false}))}\n\n  reset() {\n    this.resetTimer()\n    this.resetDots()\n    this.resetControls()\n  }\n\n  resetTimer() {\n    this.clearTimer()\n    this.timer = setInterval(this.next.bind(this), 1024 * 3)\n  }\n\n  clearTimer() {\n    clearInterval(this.timer)\n    this.timer = undefined\n  }\n\n  // TODO avoid unnecessary removal.\n  resetDots() {\n    const attr = `data-carousel-dots`\n\n    const dots = (\n      sel(this, `[${attr}]`) ||\n      this.appendChild(E(`span`, {[attr]: ``}))\n    )\n\n    x.reset(dots, {}, f.map(this.items(), (item, ind) => (\n      E(`button`, {\n        class: x.cls(`carousel-dot`, !item.hidden && `active`),\n        onclick: this.select.bind(this, ind),\n      })\n    )))\n  }\n\n  resetControls() {\n    const prev = `data-carousel-prev`\n    const next = `data-carousel-next`\n\n    remove(sel(this, `[${prev}]`))\n    remove(sel(this, `[${next}]`))\n\n    this.append(\n      E(`button`, {[prev]: ``, onclick: this.prev.bind(this)}),\n      E(`button`, {[next]: ``, onclick: this.next.bind(this)}),\n    )\n  }\n\n  prev() {this.select(this.index() - 1)}\n  next() {this.select(this.index() + 1)}\n\n  select(ind) {\n    const items = this.items()\n\n    ind = (ind + items.length) % items.length\n    const item = items[ind]\n\n    f.each(items, hide)\n    show(item)\n\n    this.resetDots()\n    this.resetTimer()\n  }\n}\ncustomElements.define(`a-carousel`, Carousel)\n\nfunction show(node) {if (node.hidden) node.hidden = false}\nfunction hide(node) {if (!node.hidden) node.hidden = true}\nfunction remove(node) {node?.remove()}\n\nfunction sel(node, sel) {return node.querySelector(f.str(sel))}\nfunction selAll(node, sel) {return node.querySelectorAll(f.str(sel))}\n\nfunction clearHash() {\n  const loc = window.location\n  if (loc.hash) {\n    const node = document.querySelector(loc.hash)\n    if (node) node.scrollIntoView()\n    window.history.replaceState(null, '', loc.origin + loc.pathname)\n  }\n}\n\nclass A extends HTMLAnchorElement {\n  constructor() {\n    super()\n    this.onclick = this.onClick\n  }\n\n  onClick() {\n    const {id} = this.dataset\n    if (id) this.hash = id\n  }\n}\ncustomElements.define(`a-a`, A, {extends: `a`})\n"],
  "mappings": "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",
  "names": []
}
