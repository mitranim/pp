// This might not work on Windows.

import * as a from '@mitranim/js/all.mjs'
import {paths as pt} from '@mitranim/js/io_deno.mjs'
import * as c from './conf.mjs'
import * as u from './util.mjs'
import * as s from './site.mjs'

await u.timing(`prune_images`, cmdPruneImages)

function cmdPruneImages() {
  if (hasArg(`--gen`)) pruneGenImages()
  if (hasArg(`--dup`)) pruneDupImages()
  if (hasArg(`--use`)) pruneUnusedImages()
}

function pruneGenImages() {
  const paths = a.filter(a.reify(imagePaths()), isGenImage)
  a.each(paths, removeSync)
}

function pruneDupImages() {
  const paths = a.reject(imagePaths(), isImagePreprocessed)
  const groups = a.values(a.index(a.reify(paths), basename))
  a.each(groups, pruneDups)
}

function pruneDups(group) {
  a.each(a.tail(group, group.sort(u.byStrLenAsc)), removeSync)
}

function pruneUnusedImages() {
  const pagePaths = a.filter(u.toNames(u.walkFiles(c.TARGET)), isHtml)
  const pageTexts = a.map(pagePaths, readFile)
  const imageLinks = a.mapFlat(pageTexts, textToImageLinks)

  const mentionedPaths = new Set(a.map(imageLinks, u.stripLeadingSlash))
  const knownPaths = new Set(knownSiteImagePaths(s.site))

  const possiblePaths = new Set(a.map(
    servableImagePaths([...mentionedPaths, ...knownPaths]),
    pt.normalize,
  ))

  const existingPaths = new Set(imagePaths())
  const unusedPaths = u.setSubtract(existingPaths, possiblePaths)
  const removePaths = a.reject(unusedPaths, isImageInRoot)

  a.each(a.reify(removePaths), removeSync)
}

// This was generated by some Django-related shit. Possibly on file upload.
// The originals are stored without those suffixes.
function isGenImage(path) {return /[.](?:large|small|square)[.]\w+$/.test(path)}

function isHtml(path) {return pt.ext(path) === `.html`}
function basename(path) {return pt.base(path)}
function readFile(path) {return Deno.readTextFileSync(path)}

function* imagePaths() {
  yield* u.toNames(u.walkFiles(`images`))
  yield* u.toNames(u.walkFiles(`uploaded/images`))
}

function removeSync(val) {
  if (hasArg(`--dry`)) console.log(`[should remove]`, val)
  else Deno.removeSync(val)
}

function textToImageLinks(text) {
  a.req(text, a.isStr)
  return a.arr(text.match(/[/]images[/](?:[\w-]+[/])*[\w-]+[.]\w+\b/g))
}

function* knownSiteImagePaths(site) {
  yield* toImagePaths(site.pages())
  yield* toImagePaths(site.authors)
}

function* toImagePaths(vals) {
  for (const val of vals) {
    const image = u.stripLeadingSlash(val.image)
    if (image) yield image
  }
}

function* servableImagePaths(paths) {
  for (const path of paths) yield* [path, pt.posix.join(`uploaded`, path)]
}

function isImageInRoot(path) {return pt.dir(path) === `images`}

// Slightly incorrect and incompatible with Windows.
function isImagePreprocessed(path) {
  return path.startsWith(`images/square`) || path.startsWith(`images/small`)
}

function hasArg(key) {return Deno.args.includes(key)}
